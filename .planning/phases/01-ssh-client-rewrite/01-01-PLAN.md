---
phase: 01-ssh-client-rewrite
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/client/client.go
  - internal/client/client_test.go
autonomous: true
requirements:
  - CLI-01
  - CLI-02
  - CLI-03
  - CLI-04
  - CLI-05
  - CLI-06
must_haves:
  truths:
    - "Client launches system ssh -R command instead of using ssh.Dial"
    - "Client parses SSH verbose output to extract allocated port"
    - "Client registers subdomain through the tunnel via HTTP"
    - "Client reconnects automatically when SSH process fails"
    - "Old ssh.Dial code is removed from codebase"
    - "Identity loaded from ~/.remo/identity.json for auth"
  artifacts:
    - path: "internal/client/client.go"
      provides: "SSH client using exec.Command instead of golang.org/x/crypto/ssh"
      min_lines: 200
      exports: ["New", "Client", "Config"]
    - path: "internal/client/client_test.go"
      provides: "Unit tests for port parsing and reconnection logic"
  key_links:
    - from: "internal/client/client.go"
      to: "exec.Command(ssh)"
      via: "os/exec package"
      pattern: "cmd := exec.Command.*ssh.*-R"
    - from: "internal/client/client.go"
      to: "~/.remo/identity.json"
      via: "identity.Load()"
      pattern: "identity.Load.*identity.json"
---

<objective>
Rewrite the SSH client to use external `ssh -R` command instead of golang.org/x/crypto/ssh library. Replace the internal SSH dialer that hangs due to GatewayPorts requirement with a reliable subprocess-based approach.

Purpose: Fix the SSH hang issue by using system SSH with `-R 0` for auto port allocation, making remo work without requiring GatewayPorts=yes on the server.
Output: Working client that uses exec.Command("ssh", ...) with robust port parsing and reconnection.
</objective>

<execution_context>
@/Users/gleicon/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/gleicon/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/STATE.md

Current client implementation uses:
- `ssh.Dial()` from golang.org/x/crypto/ssh (lines 148-190 in client.go)
- `client.Listen()` for reverse tunnel (lines 192-218)
- This requires `GatewayPorts yes` on sshd which causes hangs

New approach:
- Use `exec.Command("ssh", "-v", "-R", "0:localhost:18080", ...)` 
- Parse verbose output for "Allocated port \d+ for remote forward"
- Monitor process with `cmd.Wait()` and reconnect on exit
- Keep registration through HTTP over tunnel (already works)

Phase requirements to address:
- CLI-01: Client launches `ssh -R 0:localhost:SERVER_PORT`
- CLI-02: Client parses SSH output to detect assigned remote port
- CLI-03: Client registers subdomain with server through tunnel
- CLI-04: Client monitors SSH process and reconnects on failure
- CLI-05: Client identity loaded from `~/.remo/identity.json`
- CLI-06: Remove internal SSH dialer code
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor client to use external SSH command</name>
  <files>internal/client/client.go</files>
  <action>
Replace the SSH dialer implementation with subprocess-based approach:

1. Remove `dialSSH()` method and `setupReverseTunnel()` method completely
2. Replace `runSession()` to use `exec.Command("ssh", ...)`:
   - Build args: `["-v", "-N", "-R", "0:localhost:18080", "-o", "StrictHostKeyChecking=no", "-i", identityKeyPath, fmt.Sprintf("%s@%s:%d", user, server, port)]`
   - Use `-v` flag to get verbose output for port parsing
   - Set cmd.Stdout and cmd.Stderr to capture output
   
3. Create `parsePortFromOutput(line string) (int, error)` function:
   - Look for regex pattern: `Allocated port (\d+) for remote forward`
   - Return the port number when found
   
4. Create `monitorSSH(cmd *exec.Cmd, portChan chan<- int) error` function:
   - Read stdout/stderr line by line
   - Call parsePortFromOutput on each line
   - When port found, send to portChan
   - When cmd.Wait() returns, return error to trigger reconnect
   
5. Update `runSession()` flow:
   - Create cmd with exec.Command
   - Start cmd with cmd.Start()
   - Create portChan := make(chan int, 1)
   - Start goroutine: go monitorSSH(cmd, portChan)
   - Wait for port: remotePort := <-portChan (with timeout)
   - Call register() with the remotePort
   - Wait for cmd.Wait() to complete (blocking)
   - Return error to trigger reconnect loop
   
6. Keep existing `register()`, `handleRegisterResponse()`, backoff, and UI methods
7. Remove imports: `golang.org/x/crypto/ssh`, `math/big`
8. Add imports: `os/exec`, `regexp`

IMPORTANT: Keep identity loading and TUI integration intact. The Ed25519 key for HTTP auth header stays the same.
  </action>
  <verify>
    - Run `go build ./...` to verify no compilation errors
    - Run `go vet ./internal/client/...` for static analysis
    - Verify no references to `ssh.Dial`, `ssh.Client`, or `golang.org/x/crypto/ssh` remain in client.go
  </verify>
  <done>
    Client compiles successfully with exec.Command-based SSH, all ssh/crypto imports removed from client.go
  </done>
</task>

<task type="auto">
  <name>Task 2: Add port parsing tests and validate reconnection</name>
  <files>internal/client/client_test.go</files>
  <action>
Update tests for new subprocess-based implementation:

1. Add test for `parsePortFromOutput()`:
   ```go
   func TestParsePortFromOutput(t *testing.T) {
       tests := []struct {
           input    string
       wantPort int
           wantErr  bool
       }{
           {"debug1: Allocated port 12345 for remote forward to 127.0.0.1:18080", 12345, false},
           {"Allocated port 8080 for remote forward", 8080, false},
           {"some other debug output", 0, true},
           {"Allocated port abc for remote forward", 0, true},
       }
       // ... test implementation
   }
   ```

2. Add test for port extraction regex patterns:
   - Test various SSH client output formats (OpenSSH 8.x, 9.x)
   - Test edge cases: port 0, large ports, concurrent output lines

3. Add test for identity loading integration:
   - Verify client config properly loads from ~/.remo/identity.json
   - Test that identity is passed to register() for X-Remo-Publickey header

4. Run all tests: `go test -v ./internal/client/...`

5. Remove any tests that depend on the old ssh.Dial implementation
  </action>
  <verify>
    - Run `go test -v ./internal/client/...` - all tests pass
    - Test coverage for parsePortFromOutput is >80%
    - No test failures related to removed ssh.Dial code
  </verify>
  <done>
    All client tests pass with new subprocess-based implementation, port parsing tested with multiple SSH output formats
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify go.mod cleanup and final validation</name>
  <files>go.mod, go.sum</files>
  <action>
Final validation and cleanup:

1. Run `go mod tidy` to clean up unused dependencies:
   - golang.org/x/crypto may be removable if not used elsewhere
   - Check if any other packages import it

2. Verify no breaking changes in cmd/remo/root/connect.go:
   - Ensure connect command still works with new client
   - Verify all flags (--server, --subdomain, --upstream, etc.) still function

3. Build the entire project: `go build -o remo ./cmd/remo`

4. Verify binary runs: `./remo --help`

5. Check that the TUI integration still works:
   - Verify tea.Program initialization in New() still functions
   - Confirm sendUI() calls still compile

6. Document the change in comments:
   - Add comment at top of client.go explaining subprocess approach
   - Note: "Uses system ssh command with -R for reverse tunneling"
  </action>
  <verify>
    - `go build -o remo ./cmd/remo` succeeds
    - `./remo connect --help` shows expected flags
    - `go mod tidy` completes without issues
    - No unused imports in any modified files
  </verify>
  <done>
    Project builds successfully, binary runs, all dependencies clean, no compile errors
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **Code changes:**
   - [ ] No references to `ssh.Dial` or `golang.org/x/crypto/ssh` in client.go
   - [ ] `exec.Command("ssh", ...)` used for tunnel setup
   - [ ] Port parsing regex handles "Allocated port N" format
   - [ ] Reconnection logic triggers on SSH process exit

2. **Requirements coverage:**
   - [ ] CLI-01: `ssh -R 0:localhost:18080` command used
   - [ ] CLI-02: Port parsed from SSH verbose output
   - [ ] CLI-03: Registration through tunnel still works
   - [ ] CLI-04: Reconnection on SSH process failure
   - [ ] CLI-05: Identity loaded from ~/.remo/identity.json
   - [ ] CLI-06: Internal SSH dialer code removed

3. **Build and test:**
   - [ ] `go build ./...` succeeds
   - [ ] `go test ./internal/client/...` passes
   - [ ] `go mod tidy` removes unused crypto/ssh if possible

4. **No regressions:**
   - [ ] connect command flags still work
   - [ ] TUI integration intact
   - [ ] Registration auth header still uses identity public key
</verification>

<success_criteria>
- Client uses system `ssh` command instead of golang.org/x/crypto/ssh
- Port allocation auto-detected from SSH verbose output
- Automatic reconnection when SSH process exits
- All 6 Phase 1 requirements (CLI-01 to CLI-06) addressed
- Tests pass for port parsing logic
- Project builds without errors
- No remaining references to ssh.Dial in client package
</success_criteria>

<output>
After completion, create `.planning/phases/01-ssh-client-rewrite/01-01-SUMMARY.md`
</output>
